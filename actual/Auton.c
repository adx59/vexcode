#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  jumper1,      sensorTouch)
#pragma config(Sensor, dgtl2,  jumper2,     sensorTouch)
#pragma config(Motor,  port1,           flipper,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           ne_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           se_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           shooter_left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           nw_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           sw_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backup_intake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          shooter_right, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int despeed = 127; // default speed

// calibrate variables below
float timepercell = 775; // time to traverse one cell on the field
float timeperhalfturn = 326; // time to turn 45 degrees
float shootertime = 2700;
float intaketime = 5000;
float fliptime = 700;

void turnLeft(int turns) {
	motor[ne_motor] = -1 * despeed;
	motor[se_motor] = -1 * despeed;
	motor[nw_motor]= -1 * despeed;
	motor[sw_motor] = -1 * despeed;
	delay(turns * timeperhalfturn);
	motor[ne_motor] = 0;
	motor[se_motor] = 0;
	motor[nw_motor]= 0;
	motor[sw_motor] = 0;
}

void turnRight(int turns) {
	motor[ne_motor] = despeed;
	motor[se_motor] = despeed;
	motor[nw_motor]= despeed;
	motor[sw_motor] = despeed;
	delay(turns * timeperhalfturn);
	motor[ne_motor] = 0;
	motor[se_motor] = 0;
	motor[nw_motor]= 0;
	motor[sw_motor] = 0;
}

void go(float cells){
	int speed;
	if (cells <= 0) {
		speed = despeed * -1; // change speed to negative if param passed is negative
		cells *= -1;
	} else {
		speed = despeed;
	}
	motor[ne_motor] = speed;
	motor[se_motor] = speed;
	motor[nw_motor]= -1 * speed;
	motor[sw_motor] = -1 * speed;
	delay(cells * timepercell);
	motor[ne_motor] = 0;
	motor[se_motor] = 0;
	motor[nw_motor]= 0;
	motor[sw_motor] = 0;
}

void intakeop(int speed){
	motor[intake] = speed;
}

void shoot(float iter) {
	motor[shooter_left] = -1 * despeed;
	motor[shooter_right] = despeed;
	delay(iter * shootertime);
	motor[shooter_left] = 0;
	motor[shooter_right] = 0;
}

void flip(int flips) {
	int speed;
	if (flips < 0) {
		speed = despeed;
		flips *= -1;
	} else {
		speed = -1 * despeed;
	}
	motor[flipper] = speed;
	delay(flips * fliptime);
	motor[flipper] = 0;
}

/*
BLUE TEAM, FAR SIDE: Jumper @ Digital Port 1
BLUE TEAM, CLOSE SIDE: Jumper @ Digital Port 2
RED TEAM, FAR SIDE: Jumper @ Digital Port 3
RED TEAM, CLOSE SIDE: Jumper @ Digital Port 4
*/

task main() {
	if (SensorValue[jumper1] == 1){
		go(0.7);
		shoot(1);
		go(2);
		go(-2.6);
		turnRight(2.1);
		go(1.8);
		intakeop(-127);
		delay(1500);
		turnLeft(2);
		delay(1250);
		intakeop(0);
		go(-2.6);
	} else if (SensorValue[jumper2] == 1) {
		go(0.7);
		shoot(1.1);
		go(1.75);
		go(-2.6);
		turnLeft(2.1);
		go(1.7);
		intakeop(-127)
		delay(1500);
		go(0.2);
		turnRight(2.85);
		delay(1250);
		intakeop(0);
		go(-2.5);
	}
}
