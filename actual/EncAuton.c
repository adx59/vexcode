#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  jumper1,        sensorTouch)
#pragma config(Sensor, dgtl2,  jumper2,        sensorTouch)
#pragma config(Sensor, dgtl10, led_red,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, led_yellow,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, led_green,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           flipper,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           sw_motor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           nw_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           shooter_left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           se_motor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           ne_motor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backup_intake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          shooter_right, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 12.566 inches wheel rad
// 627.2 ticks/rot
// 25 inch cell length
// 1247.811 ticks

const int defspeed = 127;
const float rotation = 627.2;
const float remnant = 344;
const float cell = 2;
const float turnticks = 410;

void go(float rotations) {
	resetMotorEncoder(sw_motor);
	resetMotorEncoder(se_motor);

	int speed;
	float ticks = (rotations * rotation) - remnant;
	if (rotations < 0) {
		speed = defspeed * -1;
	} else {
		speed = defspeed;
	}

	if (ticks > 0){
		while ((getMotorEncoder(sw_motor) <= ticks) && (getMotorEncoder(se_motor) >= -1*ticks)) {
			motor[nw_motor] = speed;
			motor[sw_motor] = speed;
			motor[ne_motor] = -1 * speed;
			motor[se_motor] = -1 * speed;
		}
	} else {
		while ((getMotorEncoder(sw_motor) >= ticks) && (getMotorEncoder(se_motor) <= -1*ticks)) {
			motor[nw_motor] = speed;
			motor[sw_motor] = speed;
			motor[ne_motor] = -1 * speed;
			motor[se_motor] = -1 * speed;
		}
	}
	motor[nw_motor] = 0;
	motor[ne_motor] = 0;
	motor[sw_motor] = 0;
	motor[se_motor] = 0;
}

void turnLeft(float turns) {
	resetMotorEncoder(sw_motor);
	resetMotorEncoder(se_motor);

	float ticks = turns * turnticks;

	while ((getMotorEncoder(sw_motor) >= -1*ticks) || (getMotorEncoder(se_motor) >= -1*ticks)) {
		motor[nw_motor] = -1 * defspeed;
		motor[sw_motor] = -1 * defspeed;
		motor[ne_motor] = -1 * defspeed;
		motor[se_motor] = -1 * defspeed;
	}
	motor[nw_motor] = 0;
	motor[ne_motor] = 0;
	motor[sw_motor] = 0;
	motor[se_motor] = 0;
	writeDebugStreamLine("%d", getMotorEncoder(sw_motor));
}

void turnRight(int turns) {
	resetMotorEncoder(sw_motor);
	resetMotorEncoder(se_motor);

	float ticks = turns * turnticks;

	while ((getMotorEncoder(sw_motor) <= ticks) || (getMotorEncoder(se_motor) <= ticks)) {
		motor[nw_motor] = defspeed;
		motor[sw_motor] = defspeed;
		motor[ne_motor] = defspeed;
		motor[se_motor] = defspeed;
	}
	motor[nw_motor] = 0;
	motor[ne_motor] = 0;
	motor[sw_motor] = 0;
	motor[se_motor] = 0;
}

void intakeop(int speed) {
	motor[intake] = speed;
}

void shooterop(int speed) {
	motor[shooter_left] = -1 * speed;
	motor[shooter_right] = speed;
}

task main() {
	go(1.6 * cell);
	intakeop(-127);
	delay(300);
	go(-1.2 * cell);
	intakeop(0);
	turnLeft(1);
	go(0.75 * cell);
	shooterop(127);
	delay(3300);
	shooterop(0);
	intakeop(-127);
	go(0.47 * cell);
	delay(1000);
	shooterop(127);
	delay(3300);
	shooterop(0);
	go(0.8* cell);
	intakeop(0);
}
